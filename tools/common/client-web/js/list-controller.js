/**
 * Script: common/client-web/js/list-controller
 *
 * Simplifies the creation of structured lists.
 * 
 * *Overview*
 * 
 * This file defines several classes that make it easy to create attractive,
 * sortable, searchable lists of data.  There are three pieces involved in
 * table creation: the *view*, which creates the HTML for each list item, 
 * the *controller*, which handles searching and sorting and feeding data 
 * from the model to the view, and the *model*, which provides the data
 * that the view displays through the controller.
 * 
 * *The list view*
 * 
 * The view is handled by a delegate for the <I3.ListController> class.  A 
 * delegate for <I3.ListController> must implement the following methods:
 * 
 *   o  renderListItem(item, [index])
 * 
 * Additionally, the following methods may be defined in the delegate class 
 * to provide more customized action:
 * 
 *   o  compareFieldForItem(field, item1, item2)
 * 
 * *The controller class*
 * 
 * The view is managed by the <I3.ListController> class.  Displaying a list 
 * takes at minimum, the following steps:
 * 
 *   o  Tell it where to render the list
 *   o  Tell it where to get the data for the list
 *   o  Tell it to display
 * 
 * The first step -- providing a place for the list -- is performed when 
 * you create an instance of <I3.ListController>.  You'll supply it with a 
 * reference to a DIV that the view can "own" -- that is, one that it can 
 * clear and re-create at will.
 * 
 * The second step is performed by calling <I3.ListController::setModel> and 
 * supplying a list model object to the controller.  A model object is any 
 * object that provides several specific methods that the view will look for 
 * (known as the "list model protocol"), such as how many items are in the 
 * list, etc.  See the description of <I3.ListController> for details on what 
 * methods are expected.
 * 
 * The third step is performed by simply calling <I3.ListController::display>.
 * This causes the controller to query the model, pass the data to the 
 * delegate for rendering and then displaying it in the specified element on 
 * the page.
 * 
 * *Model classes*
 * 
 * While you can easily create your own list model classes with completely
 * custom functionality, a couple of general-use model classes are included.
 * These classes implement the list model protocol for some of the more
 * common cases so that you don't have to.
 * 
 * The first model class provided is <I3.ArrayListModel>.  When you create
 * an instance of this, you will provide an array of JavaScript objects that 
 * the model will make available to the controller.  A single call to 
 * <I3.ArrayListModel::enableIndex> will turn on search-as-you-type support 
 * for the table.  For more control, <I3.ArrayListModel::addFieldToIndex> 
 * can be used to explicitly define which fields are used for the index.  
 * Similarly, <I3.ArrayListModel::addFieldToSortList> will specify which 
 * fields are sortable.
 * 
 * The second model class is <I3.WebServiceListModel>.  This extends
 * `ArrayListModel` with web service support: you simply provide the path
 * to a web service that returns an array, and it takes care of the rest.
 * Like `ArrayListModel`, you can easily enable search-as-you-type support
 * and override index and sort behavior.
 * 
 * *Keyword indexing*
 * 
 * The <I3.ListKeywordIndex> class is used to associate keywords with row 
 * indices in the table model.  A keyword index is automatically generated by 
 * the included model classes when `enableIndex` is called, but if you're 
 * creating your own table model class, you can create your own `KeywordIndex` 
 * instance and use it for searches.
 * 
 * Though `I3.ListKeywordIndex` was created for use with `I3.ListController`, 
 * which expects words to be associated with model indices, it can be used for
 * virtually anything that would benefit from an optimized index.  Keywords
 * can be associated with numbers, strings, or objects such as DOM elements;
 * whatever value you associate with the keyword is what will be returned by
 * <I3.ListKeywordIndex::search>.
 * 
 * ListKeywordIndex is identical to <I3.KeywordIndex> which is found with 
 * <I3.TableView>.
 * 
 * *Examples*
 * 
 * Assume that you have an array of JavaScript objects named `myArray`,
 * and a `div` element named `myListContainer` that the table will go in.
 * The following code would create a list from the array:
 * 
 * (start example)
 *   var controller = new I3.ListController(I3.ui.get("myListContainer"));
 *   controller.setModel(new I3.ArrayListModel(myArray));
 *   controller.setDelegate(self);
 *   self.renderListItem = function(item) { return item[property]; };
 *   controller.display();
 * (end example)
 * 
 * These five lines are all that's necessary to get a table up and running.
 * But suppose your requirements are more complex.  Let's say you have a web
 * service at the path "/assets/data/vehicles" that returns an array of
 * JavaScript objects representing vehicles.  Each vehicle object contains
 * three fields that you want to turn into areas in the list: "make",
 * "model", and "year".  In addition, each vehicle has an "owner" field,
 * which is an object representing a person.  The owner has two objects:
 * "first_name" and "last_name".  You just want to display the name in a
 * single field as "Last, First".
 * 
 * You'll need a custom comparator method in your delegate that can compare 
 * the fields in your object since JavaScript doesn't know how to sort the 
 * custom fields in your object by itself.
 * 
 * (start example)
 *   @method compareFieldForItem(field, item1, item2) {
 *     switch(field) {
 *       case "owner":
 *         var name1 = item1.last_name + ", " + item1.first_name;
 *         var name2 = item2.last_name + ", " + item2.first_name;
 *         if (name1 < name2) return -1;
 *         if (name1 > name2) return 1;
 *         return 0;
 *       default:
 *         item1 = item1.toString().toLowerCase();
 *         item2 = item2.toString().toLowerCase();
 *         if (item1 < item2) return -1;
 *         if (item1 > item2) return 1;
 *         return 0;
 *     }
 *   }
 * (end example)
 * 
 *
 * Credits:
 * 
 *   Written by
 *     Nathan Mellis (nathan@mellis.us) and 
 *     Marshall Elfstrand (marshall@vengefulcow.com).
 * 
 * Copyright / License:
 * 
 *   Copyright 2009 Mission Aviation Fellowship
 * 
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 * Version:
 *   $Id: list-controller.js 22 2007-12-12 23:26:00Z melfstrand $
 */

// ---------------------------------------------------------------------------

/**
 * Module: I3
 *
 * Module containing class definitions and data shared by all
 * intranet applications.
 */
@module I3;

// ---------------------------------------------------------------------------

/**
 * Class: I3.ListController
 *
 * Renders an HTML list from data provided by a model.  The list view can
 * be sorted by selecting a field from the box, and if the model has a
 * keyword index, an instant-search field will be provided so that the user
 * can filter the list contents on-the-fly.
 * 
 * To use the list view, a *list model* must be provided.  List models
 * are JavaScript objects that follow a certain protocol: namely, they must
 * support a minimum of two specific methods that the view expects to find.
 * These methods are:
 * 
 *   - `getItemCount()` - returns the number of items in the data set
 *   - `getItemAt(index)` - returns the object that the given index in the 
 *                          list.
 * 
 * In addition, several other methods can be optionally provided by the list
 * model that will enable extra functionality if the controller finds them:
 * 
 *   - `preload(onloadHandler)` - loads the data in the list model and calls
 *     the `onloadHandler` function when it is finished.  If present, the
 *     controller will display a "Loading" message and wait for the handler
 *     to be called before attempting to display the data in the model.  This
 *     can be particularly useful for models that obtain their data from a
 *     web service request.
 *   - `getKeywordIndex()` - returns an <I3.KeywordIndex> instance that maps
 *     keywords to row indices in the table model.  If present, the table
 *     view will display an instant-search box for filtering the table on
 *     the fly.
 *   - `addFieldToIndex(field, ...)` - adds a particular property in the 
 *     object to the index so that the data in that property is available 
 *     find-as-you-type searches if the index is enabled.
 *   - `addFieldToSortList(field)` - adds a field in the object as being 
 *     available for searching.  In this case, `field` must be an object that 
 *     contains the following properties:
 *       o label - the text to be displayed in the SELECT box
 *       o field - the field to be used to sort.  May contain multiple levels
 *       o reverse - set to true if the sort should be in reverse order
 * 
 * See the <I3.ListController::setTitle>, <I3.ListController::sort>, and 
 * <I3.ListController::search> methods for more list controller functionality.
 * 
 * Parameters:
 *   container - the HTML DOM element into which the list will be rendered
 */
@class ListController(container) {
  
  var SEARCH_DELAY = 250;     // Delay before search begins after keypress (ms)
  
  var _container;             // List will be created in this
  var _searchTextBox;         // Text box containing search text
  var _searchStatusText;      // Span containing search status
  var _searchTimer;           // Delays search after last keypress
  var _modelDidPreload;       // Set to true when model has preloaded
  var _modelElementMap;       // Maps model indices to list item elements
  var _modelVisibilityMap;    // Tracks which model indices are visible
  var _modelSortMap;          // Model indices sorted by the selected field
  var _sortField;             // Index of the field to sort by
  var _sortIsReversed;        // Set to true when sort is descending
  var _sortableFieldChooser;  // The SELECT box for sorting records
  
  /**
   * Private Method: _initialize
   *
   * Initializes the list controller.  This is called automatically when
   * an instance of the class is created.
   */
  @method _initialize(container) {
    if (typeof container == "string") container = I3.ui.get(container);
    _container = container;
    _modelDidPreload = false;
  }

  /**
   * Method: getModel
   * Returns the list model that will supply the data to be displayed.
   *
   * Method: setModel
   * Sets the list model that will supply the data to be displayed.
   * See the documentation for <I3.ListController> for details on what is
   * expected of a list model.
   */
  @property model;
  
  /**
   * Method: getTitle
   * Returns the title that will be displayed above the list.
   *
   * Method: setTitle
   * Sets the title that will be displayed above the list.
   * Set to `null` for no title.
   */
  @property title;
  
  /**
   * Method: getDelegate
   * Returns the delegate object for the list controller.
   *
   * Method: setDelegate
   * 
   * Sets the delegate object for the list controller.
   * 
   * The object must provide the following methods:
   * 
   *   renderListItem - supplies the HTML for each list item as it's rendered
   * 
   * The object may provide any or all of the following methods:
   * 
   *   compareFieldForItem - a function that will be used to sort the list 
   *     by a particular field.  The function should supply a way to 
   *     accurately sort the list for every field that is specified in 
   *     <I3.ArrayListModel::addFieldToSortList>.
   */
  @property delegate;


  /**
   * Method: getSearchBoxContainer
   * Returns the element in which the search box will be placed if enabled.
   */
  @propertyReader searchBoxContainer;
  
  /**
   * Method: setSearchBoxContainer
   * Sets the element in which the search box will be placed if enabled.
   * By default, a container element is created above the table to hold
   * the search box and its associated status text.  Setting this property
   * will prevent the creation of this element and add the search box and
   * its label to the given container instead.
   */
  @method setSearchBoxContainer(container) {
    _searchBoxContainer = I3.ui.clear(container);
  }


  /**
   * Method: search
   *
   * Filters the list to only items matching the search string.
   * This will call the model's `getKeywordIndex()` method and use
   * it to perform the search.
   * 
   * The keyword index is expected to return the items in the list model
   * that match the search string.  The view will automatically handle the
   * mapping of the list model to the sorted table rows.
   *
   * Parameters:
   *   str - the text to search for in the list
   */
  @method search(str) {
    if (self._modelIsMissing()) return;
    if (self._delegateIsMissing()) return;

    // Update the text in the search box in case this was
    // done programmatically.
    if (_searchTextBox) _searchTextBox.value = str;

    // Find the rows in the model that match the search string and set
    // them to `true` in the model visibility map.
    var resultCount = -1;
    str = (str == null) ? "" : I3.util.trim(str);
    if (str.length == 0) {
      // No search; all rows are visible.
      _modelVisibilityMap = {};
      for (var i = 0; i < _model.getItemCount(); i++) {
        _modelVisibilityMap[i] = true;
      }
    }
    else {
      
      // Hide all items in the model visibility map if it doesn't exist.
      if (_modelVisibilityMap == null) {
        _modelVisibilityMap = {};
        for (var i = 0; i < _model.getItemCount(); i++) {
          _modelVisibilityMap[i] = false;
        }
      }
      
      // Use the keyword index to get matching model items.
      if (_model.getKeywordIndex == null) {
        I3.ui.displayError("The list cannot be searched because the " +
          "model does not have a keyword index.");
        return;
      }
      var index = _model.getKeywordIndex();
      var searchTerms = str.split(/[^\w]/);
      var matches;
      if (searchTerms.length == 1) {
        // Just one search term.  We can use the search results as-is.
        matches = index.search(str);
      }
      else {
        // Multiple search terms.  Merge the matches into a single array
        // that only contains results shared across search terms.
        var matchMap = {};
        var newMatchMap;
        matches = index.search(searchTerms[0]);
        for (var i = 0; i < matches.length; i++) {
          matchMap[matches[i]] = true;
        }
        for (var i = 1; i < searchTerms.length; i++) {
          if (searchTerms[i].length > 0) {
            newMatchMap = {};
            matches = index.search(searchTerms[i]);
            for (var j = 0; j < matches.length; j++) {
              if (matches[j] in matchMap) newMatchMap[matches[j]] = true;
            }
            matchMap = newMatchMap;
            newMatchMap = null;
          }
        }
        matches = [];
        for (var i in matchMap) { matches.push(i); }
      }
      resultCount = matches.length;
      for (var i = 0; i < resultCount; i++) {
        _modelVisibilityMap[matches[i]] = true;
      }
    }
    
    // Update the result count display.
    if (_searchStatusText) {
      if (resultCount == -1) {
        _searchStatusText.style.display = "none";
      }
      else {
        var matchText = resultCount == 1 ? " match" : " matches";
        _searchStatusText.firstChild.data =
          "Found " + resultCount + matchText;
        _searchStatusText.style.display = "inline";
      }
    }

    // Sort the model visibility map indices by their sorted item
    // indices so that the alternating row colors are ordered properly.
    var indices = [];
    for (var index in _modelVisibilityMap) { indices.push(index); }
    indices.sort(function(a, b) {
      return _modelElementMap[a].listIndex - _modelElementMap[b].listIndex;
    });

    // Display items that are `true` and hide rows that are `false`
    // in the visibility map.  Once the display property has been set,
    // items that are `false` are removed from the visibility map so
    // that further searches don't loop through them unnecessarily.
    // Items that are `true` are reset to `false` for the next search.
    var useAlternateStyle = false;
    var index;
    for (var i = 0; i < indices.length; i++) {
      index = indices[i];
      if (_modelVisibilityMap[index] == true) {
        _modelElementMap[index].style.display = "";
        if (useAlternateStyle)
          _modelElementMap[index].className = "i3listItemAlt";
        else _modelElementMap[index].className = "i3listItem";
        useAlternateStyle = !useAlternateStyle;
        _modelVisibilityMap[index] = false;
      }
      else {
        _modelElementMap[index].style.display = "none";
        delete _modelVisibilityMap[index];
      } // end if
    } // end for
  }

  /**
   * Method: sort
   *
   * Sorts the list by a given column.
   * 
   * If the list has already been displayed, the sort will take effect
   * immediately and the list will be re-displayed.  Otherwise the
   * list will be sorted when <I3.ListController::display> is called.
   *
   * If the delegate supports the `compareFieldForItem` method,
   * it will be used to compare items as the sort is taking place.
   * Otherwise a generic sort will be performed on the values returned
   * by the model's `getItemAt` method.
   * 
   * Parameters:
   *   field - the field to sort by
   *   shouldReverse - `true` if the sort should be done in reverse
   *     (i.e. in descending order).  Defaults to `false`.
   *   shouldRender - `true` if the list should re-display afterward.
   *     Defaults to `true`.
   */
  @method sort(field, shouldReverse, shouldRender) {
    if (shouldReverse == null) shouldReverse = false;
    if (shouldRender == null) shouldRender = true;
    var oldField = _sortField;
    _sortField = field;
    // If _sortField hasn't been specified, use the first sort field
    if ((!_sortField || _sortField == "") && 
        _model.getSortableFields().length > 0) {
      _sortField = _model.getSortableFields()[0].field;
    }
    _sortIsReversed = shouldReverse;
    if (!_modelDidPreload) return;
    if (self._modelIsMissing()) return;
    if (self._delegateIsMissing()) return;
    var itemCount = _model.getItemCount();
    if (_modelSortMap == null) {
      _modelSortMap = [];
      for (var i = 0; i < itemCount; i++) {
        _modelSortMap.push(i);
      }
    }
    if (_sortField && _sortField != "") {
      if (_delegate.compareFieldForItem) {
        // Use delegate's compare function to sort the list.
        _modelSortMap.sort(function(a, b) {
          var value1, value2;
          try { value1 = eval("_model.getItemAt(a)." + _sortField);
          } catch (ex) { value1 = null; }
          try { value2 = eval("_model.getItemAt(b)." + _sortField);
          } catch (ex) { value2 = null; }

          if (!value1) return -1;
          if (!value2) return 1;

          return _delegate.compareFieldForItem(_sortField, value1, value2);
        });
      }
      else {
        // Sort the list via a generic JavaScript sort.
        _modelSortMap.sort(function(a, b) {
          var value1, value2;
          try { value1 = eval("_model.getItemAt(a)." + _sortField);
          } catch (ex) { value1 = null; }
          try { value2 = eval("_model.getItemAt(b)." + _sortField);
          } catch (ex) { value2 = null; }

          if (!value1) return -1;
          if (!value2) return 1;

          a = value1.toString().toLowerCase();
          b = value2.toString().toLowerCase();

          if (a < b) return -1;
          if (a > b) return 1;
          return 0;
        });
      }
    }
    if (shouldReverse) _modelSortMap.reverse();
    if (shouldRender) self._render();
  }
  
  /**
   * Method: display
   *
   * Displays the data in the list.
   */
  @method display() {
    if (self._modelIsMissing()) return;
    if (self._delegateIsMissing()) return;
    if (_model.preload && !_modelDidPreload) {
      I3.ui.clear(_container);
      var loadingDiv = I3.ui.create("div");
      var loadingImg = I3.ui.create("img");
      loadingImg.src = "/$theme/client-web/img/working.gif";
      loadingDiv.className = "i3listLoading";
      loadingDiv.appendChild(I3.ui.text("Loading... "));
      loadingDiv.appendChild(loadingImg);
      _container.appendChild(loadingDiv);
      _model.preload(self._onModelPreload);
    }
    else self._onModelPreload();
  }
  
  /**
   * Private Method: _onModelPreload
   *
   * Called when the model has finished loading.
   *
   * Parameters:
   *   wasSuccessful - set to `false` if the data had errors loading;
   *     this will prevent the list from being displayed.  Defaults
   *     to `true`.
   */
  @method _onModelPreload(wasSuccessful) {
    if (wasSuccessful == null) wasSuccessful = true;
    if (wasSuccessful) {
      _modelDidPreload = true;
      self._render();
    } else I3.ui.clear(_container);
  }
  
  /**
   * Private Method: _render
   *
   * Creates the list from the model.
   */
  @method _render() {
    // Create the sorted list if it doesn't already exist.
    if (_modelSortMap == null) self.sort(_sortField, _sortIsReversed, false);

    // Save the previous search text for re-creating the search.
    var previousSearch = _searchTextBox ? _searchTextBox.value : "";
    var hasSearch = (previousSearch.length > 0);
    
    // Ensure that the delegate has the proper render method
    if (!_delegate.renderListItem) {
      alert("Delegate needs a 'renderListItem' method.");
      return;
    }

    // Create the array of list items from the data.
    var i, j;
    var items = [];
    var item;
    for (i = 0; i < _modelSortMap.length; i++) {
      item = _delegate.renderListItem(
        _model.getItemAt(_modelSortMap[i]), _modelSortMap[i]);
      if (hasSearch) items.push('<li style="display:none">' + item + '</li>');
      else items.push('<li>' + item + '</li>');
    }
    var list = "<ul>" + items.join("") + "</ul>";
    
    // Reset the container, removing the "loading" text if applicable.
    I3.ui.clear(_container);
    if (_searchBoxContainer == null) {
      _searchTextBox = null;
      _searchStatusText = null;
      _sortableFieldChooser = null;
    }
    
    // Create the title if applicable.
    if (_title) {
      var titleH = I3.ui.create("h4");
      titleH.className = "i3listTitle";
      titleH.appendChild(I3.ui.text(_title));
      _container.appendChild(titleH);
    }
    
    var searchDiv;
    if (_searchBoxContainer) searchDiv = _searchBoxContainer;
    
    var showSortFieldChooser = (
        _model.getSortableFields && 
        _model.getSortableFields().length > 0 &&
        _sortableFieldChooser == null);
    
    // Create a sort box if applicable
    if (showSortFieldChooser) {
      var sortContainer = I3.ui.create("div");
      sortContainer.style.cssText = "float:right;";
      _sortableFieldChooser = I3.ui.create("select");
      _sortableFieldChooser.onchange = self._onFieldSort;
      var sortableFields = _model.getSortableFields();
      
      for (var i=0; i<sortableFields.length; i++) {
        var field = sortableFields[i];
        var selected = (_sortField == field.field && 
                        _sortIsReversed == field.reverse ? true : false);
        var option = I3.ui.create("option");
        option.appendChild(I3.ui.text(field.label));
        option.value = field.field;
        option.selected = selected;
        _sortableFieldChooser.appendChild(option);
      }
      
      if (searchDiv == null) {
        searchDiv = I3.ui.create("div");
        searchDiv.className = "i3listSearch";
        _container.appendChild(searchDiv);
      }
      
      sortContainer.appendChild(I3.ui.text("Sort: "));
      sortContainer.appendChild(_sortableFieldChooser);
      searchDiv.appendChild(sortContainer);
    }
    
    // Create search box if applicable.
    if (_model.getKeywordIndex && _searchTextBox == null) {
      _searchTextBox = I3.ui.create("input");
      _searchTextBox.onkeyup = self._onSearchKeyUp;
      _searchStatusText = I3.ui.create("span");
      _searchStatusText.className = "i3listSearchStatus";
      _searchStatusText.appendChild(I3.ui.text("Sorting..."));
      if (searchDiv == null) {
        searchDiv = I3.ui.create("div");
        searchDiv.className = "i3listSearch";
        _container.appendChild(searchDiv);
      }
      searchDiv.appendChild(I3.ui.text("Find: "));
      searchDiv.appendChild(_searchTextBox);
      searchDiv.appendChild(_searchStatusText);
      
    }
    
    if (showSortFieldChooser) {
      var clearDiv = I3.ui.create("div");
      clearDiv.style.clear = "right";
      searchDiv.appendChild(clearDiv);
    }
    
    // Add the table data to the container.
    var listContainer = I3.ui.create("div");
    listContainer.className = "i3listContainer";
    listContainer.innerHTML = list;
    _container.appendChild(listContainer);

    // Build the model-to-LI-element map
    var lis =
      _container.getElementsByTagName("ul")[0].getElementsByTagName("li");
    _modelElementMap = [];
    for (i = 0; i < lis.length; i++) {
      lis[i].listIndex = i;
      _modelElementMap[_modelSortMap[i]] = lis[i];
    }
    
    // Hide items that do not match the current search string.
    // This will also take care of the alternating-row formatting.
    _modelVisibilityMap = null;
    self.search(previousSearch);
  }

  /**
   * Private Method: _onSearchKeyUp
   *
   * Called when a key has been pressed in the search text box.
   * 
   * Parameters:
   *   e - the key-up event parameters
   */
  @method _onSearchKeyUp(e) {
    // Reset the search timeout.  We only want to call the search routine
    // when the user has finished typing.
    if (_searchTimer != null) clearTimeout(_searchTimer);
    _searchTimer = setTimeout(self._onSearchDelayComplete, SEARCH_DELAY);
    _searchStatusText.firstChild.data = "Finding...";
    I3.ui.show(_searchStatusText, "inline");
  }
  
  /**
   * Private Method: _onSearchDelayComplete
   * 
   * Called when the search delay has finished after a user keypress
   * and a search can begin.
   */
  @method _onSearchDelayComplete() {
    clearTimeout(_searchTimer);
    _searchTimer = null;
    self.search(_searchTextBox.value);
  }

  /**
   * Private Method: _onFieldSort
   *
   * Called when the sort field changes.  The field is
   * determined and <I3.ListController::sort> is called.
   * 
   * Parameters:
   *   e - the click event parameters
   */
  @method _onFieldSort(e) {
    var targ = I3.ui.getEvent(e).getTarget();
    if (targ != null) {
      if (_searchStatusText) {
        _searchStatusText.firstChild.data = "Sorting...";
        I3.ui.show(_searchStatusText, "inline");
      }
      var field = _model.getSortableFields()[targ.selectedIndex];
      // Slight delay to give "sorting..." message time to appear
      setTimeout(function() { self.sort(field.field, field.reverse); }, 100);
    }
  }

  /**
   * Private Method: _modelIsMissing
   *
   * Checks to see if the model is missing or if any of the required
   * methods are missing from the model.  If any problems are detected,
   * an error will be displayed and `true` will be returned.
   * 
   * Returns:
   *   `true` if any problems are detected with the model,
   *   `false` if the model is valid
   */
  @method _modelIsMissing() {
    if (_model == null) {
      I3.ui.displayError("The list view cannot be displayed because no " +
        "model has been supplied via setModel().");
      return true;
    }
    var missingMethods = [];
    if (_model.getItemCount == null)
      missingMethods.push("getItemCount()");
    if (_model.getItemAt == null)
      missingMethods.push("getItemAt(index)");
    if (missingMethods.length > 0) {
      I3.ui.displayError("The list view cannot be displayed because the " +
        "model is missing the following method(s): " +
        missingMethods.join(", "));
    }
    return false;
  }
  
  /**
   * Private Method: _delegateIsMissing
   *
   * Checks to see if the delegate is missing or if any of the required 
   * methods are missing from the delegate.  If any problems are detected, 
   * an error will be displayed and `true` will be returned.
   * 
   * Returns:
   *   `true` if any problems are detected with the delegate, 
   *   `false` if the delegate is valid
   */
  @method _delegateIsMissing() {
    if (_delegate == null) {
      I3.ui.displayError("The list view cannot be displayed because no " +
        "delegate has been supplied via setDelegate().");
      return true;
    }
    var missingMethods = [];
    if (_delegate.renderListItem == null)
      missingMethods.push("renderListItem()");
    if (missingMethods.length > 0) {
      I3.ui.displayError("The list view cannot be displayed because the " +
        "delegate is missing the following method(s): " +
        missingMethods.join(", "));
    }
    return false;
  }

  self._initialize(container);
} // end I3.ListController


// ---------------------------------------------------------------------------


/**
 * Class: I3.ArrayListModel
 *
 * Implements the list model protocol for the common case of displaying
 * an array of JavaScript objects.
 * 
 * Using this class can be as simple as creating an instance and passing
 * in an array as a parameter:
 * 
 * (start example)
 *   var model = new ArrayListModel(myArray);
 * (end example)
 * 
 * In this simple case, columns will be created from the fields in each
 * JavaScript object (using the first object as a template for what fields
 * to expect), and each value will be displayed as a string.  Dates will
 * be rendered using a locale-specific format.
 * 
 * Find-as-you-type is activated by calling <I3.ArrayListModel::enableIndex>.
 * This will generate an <I3.ListKeywordIndex> and populate it with data from
 * the array.  Note that the index will use the values in the array itself,
 * not the formatted values, so formatter functions can be free to create
 * links or image tags or anything else without throwing off the index.
 * 
 * Parameters:
 *   arr - the array of data to display
 */
@class ArrayListModel(arr) {

  var _data;           // array of table data
  var _keywordIndex;   // instance of I3.ListKeywordIndex
  var _indexFields     = [];
  
  /**
   * Method: getSortableFields
   * Returns an array of the fields that are sortable.
   */
  @propertyReader sortableFields = [];

  /**
   * Private Method: _initialize
   *
   * Initializes the model.
   * 
   * Parameters:
   *   arr - the array of data to display
   */
  @method _initialize(arr) {
    _data = arr;
  }

  /**
   * Private Method: _indexData
   * 
   * Fills the keyword index with the data from the array.
   */
  @method _indexData() {
    
    // Set up some values to compare dates against so that we know
    // which rows to associate "today" and "yesterday" with.
    var today = self._stripTime(new Date());
    var yesterday = new Date(today - 86400000);
    
    // Loop through the data row by row, column by column.
    var value, dateValue, valueParts;
    var i, j, k;
    for (i = 0; i < _data.length; i++) {
      for (j = 0; j < _indexFields.length; j++) {
        try { value = eval("_data[i]." + _indexFields[j]); 
        } catch (ex) { value = null; };
        
        if (value == null) value = "";
        // Handle dates specially.
        if (value.constructor == Date) {
          // Look for today/yesterday values.
          dateValue = self._stripTime(value);
          if (value == today)
            _keywordIndex.associateKeywordWithIdentifier("today", i);
          else if (value == yesterday)
            _keywordIndex.associateKeywordWithIdentifier("yesterday", i);
          // Index the locale-specific date string.  Since this is
          // what will generally be shown for the date in the table,
          // it makes sense to index it that way.
          value = value.toLocaleDateString();
          _keywordIndex.associateKeywordWithIdentifier(value, i);
        } else {
          // Split the string value into words and index each word.
          valueParts = value.toString().split(/[^\w]/);
          for (k = 0; k < valueParts.length; k++) {
            if (valueParts[k].length > 0)
              _keywordIndex.associateKeywordWithIdentifier(valueParts[k], i);
          } // end for
        } // end if
      } // end for
    } // end for
    
    // Now that everything is in the index, we can optimize it for searching.
    _keywordIndex.prepareForSearch();
  }
  
  /**
   * Private Method: _stripTime
   *
   * Strips the time value from a Date object.
   *
   * Parameters:
   *   dt - the Date object from which the time will be removed
   * 
   * Returns:
   *   A `Date` object with no specific time set
   */
  @method _stripTime(dt) {
    return new Date(dt.getFullYear(), dt.getMonth(), dt.getDate());
  }

  // -------------------------------------------------------------------------
  // Group: List Model Protocol
  // -------------------------------------------------------------------------

  /**
   * Method: preload
   *
   * Loads the data needed by the model.
   * 
   * This will auto-generate the columns if necessary.
   * 
   * Parameters:
   *   onloadHandler - function to call when the data has been loaded.
   *     A boolean argument will be passed to the function to tell whether
   *     the load was successful or not (i.e. `true` if the data was loaded).
   */
  @method preload(onloadHandler) {
    onloadHandler(true);
  }

  /**
   * Method: getItemCount
   *
   * Returns the number of rows to display in the table.
   */
  @method getItemCount() {
    return _data.length;
  }
  
  /**
   * Method: getItemAt
   *
   * Returns the HTML to display in the cell for the given row/column pair.
   * 
   * See <I3.ArrayTableModel::addColumn> for details on how to override
   * the output for a cell in array-based table models.
   *
   * Parameters:
   *   index - the index of the row being rendered by the view
   */
  @method getItemAt(index) {
    return _data[index];
  }
  
  // -------------------------------------------------------------------------
  // Group: Customization
  // -------------------------------------------------------------------------
  
  /**
   * Method: addFieldToIndex
   *
   * Adds `field` to the list of fields that are indexed.  May take either 
   * multiple arguments, or an array of items.  The items should be the field 
   * that is to be indexed (e.g. "person_name" => item.person_name).  It may 
   * also take multiple levels of properties (e.g. "kind.description")
   *
   * Parameters:
   *   field - description
   */
  @method addFieldToIndex(field) {
    for (var i=0; i<arguments.length; i++) {
      if (typeof arguments[i] == "string") _indexFields.push(arguments[i]);
      else if (arguments[i].length > 0) {
        for (var j=0; j<arguments[i].length; j++) 
          _indexFields.push(arguments[i][j]);
      }
    }
  }
  
  /**
   * Method: addFieldToSortList
   *
   * Adds a field to the list of sortable fields.  May take multiple comma-
   * separated values for adding more than one field.
   * 
   * Each argument should be an object with the following structure:
   * 
   * (start example)
   * {
   *   label: "Field Name", 
   *   field: "property.name", 
   *   reverse: false
   * }
   * (end example)
   *
   * Parameters:
   *   field - an object containing the information about the field to sort
   */
  @method addFieldToSortList(field) {
    for (var i=0; i<arguments.length; i++) {
      if (arguments[i].label && arguments[i].field)
        _sortableFields.push(arguments[i]);
      else if (arguments[i].length > 0) {
        for (var j=0; j<arguments[i].length; j++)
          _sortableFields.push(arguments[i][j]);
      }
    }
  }
  
  /**
   * Method: enableIndex
   *
   * Turns on keyword index support for the table.  This will cause
   * <I3.ListController> to automatically display an instant-search box for
   * filtering data.
   */
  @method enableIndex() {
    if (_keywordIndex == null) {
      _keywordIndex = new I3.ListKeywordIndex();
      if (_data.length > 0) self._indexData();
      self.getKeywordIndex = function() { return _keywordIndex; }
    }
  }
  
  self._initialize(arr);
}


// ---------------------------------------------------------------------------


/**
 * Class: I3.WebServiceListModel
 *
 * Implements the list model protocol for the common instance of retrieving
 * an array from a web service.
 * 
 * This provides the same functionality as <I3.ArrayListModel>, except
 * you provide it with the path of a web service instead of an array.
 * The list view will automatically display a "Loading" message as the
 * data loads, and the data will be displayed when the response has been
 * received.
 * 
 * The response is expected to be an array.  If the response is an object
 * and the array to be displayed is a member of the object, the path to the
 * array can be specified using <I3.WebServiceTableModel::setObjectKeyPath>.
 * 
 * As with <I3.ArrayListModel>, find-as-you-type can be enabled 
 * via `enableIndex()`.
 * 
 * Parameters:
 *   uri - the path of the web service to load
 */
@class WebServiceListModel(uri) {

  var _base;             // underlying I3.ArrayListModel instance
  var _webServiceURI;    // path to web service
  var _onloadHandler;    // function to call when data has loaded
  var _columns;          // custom-defined columns
  var _indexEnabled;     // true if enableIndex() has been called

  /**
   * Private Method: _initialize
   *
   * Initializes the table model.
   * 
   * Parameters:
   *   uri - the path of the web service to load
   */
  @method _initialize(uri) {
    _webServiceURI = uri;
  }

  /**
   * Private Method: _onWebServiceResponse
   *
   * Called when the web service has responded.  Loads the data into
   * the internal array table model and calls the handler function that 
   * was given when `preload()` was called.
   *
   * Parameters:
   *   response - an `I3.ObjectResponse` containing the array of data
   */
  @method _onWebServiceResponse(response) {
    var status = false;
    if (response.isOK()) {
      var data = response.getObject();
      // Follow the object key path if necesssary.
      if (_objectKeyPath && _objectKeyPath.length > 0) {
        var navigatePath =
          eval('function(obj) { return obj.' + _objectKeyPath + '; }');
        data = navigatePath(data);
      }
      // Create the array table model
      _base = new I3.ArrayListModel(data);
      if (_indexEnabled) _base.enableIndex();
      status = true;
    }
    // Call the handler method that was specified in `preload()`.
    if (_onloadHandler) _onloadHandler(status);
  }

  // -------------------------------------------------------------------------
  // Group: List Model Protocol
  // -------------------------------------------------------------------------

  /**
   * Method: preload
   *
   * Loads the data needed by the model.
   * 
   * This will start the web service request.  The list view will be
   * notified when it is finished via the `onloadHandler` function.
   * 
   * Parameters:
   *   onloadHandler - function to call when the data has been loaded.
   *     A boolean argument will be passed to the function to tell whether
   *     the load was successful or not (e.g. `true` if the data was loaded).
   */
  @method preload(onloadHandler) {
    _onloadHandler = onloadHandler;
    I3.client.getObject(_webServiceURI, self._onWebServiceResponse);
  }

  /**
   * Method: getItemCount
   *
   * Returns the number of items to display in the list, or `-1` if the
   * data has not yet been loaded.
   */
  @method getItemCount() {
    if (_base) return _base.getRowCount();
    else return -1;
  }
  
  /**
   * Method: getItemAt
   *
   * Returns the item at the given `index` in the array.
   * 
   * Parameters:
   *   index - the index of the item being rendered by the view
   */
  @method getItemAt(index) {
    if (_base) return _base.getItemAt(index);
    else return null;
  }
  

  // -------------------------------------------------------------------------
  // Group: Customization
  // -------------------------------------------------------------------------
  
  /**
   * Method: getObjectKeyPath
   * Returns the path to the array in the response data.
   *
   * Method: setObjectKeyPath
   * Sets the path to the array in the response data.
   * By default, it is assumed that the root object returned by the
   * web service is the array.  If the array to be displayed is a
   * property of the root object (even one that is multiple levels deep),
   * the name of the property can be set here.  A chain of properties
   * can be specified using dot notation (e.g. "resources.computers").
   */
  @property objectKeyPath;

  /**
   * Method: addFieldToIndex
   *
   * Adds a field to the index.
   * 
   * Parameters:
   *   field - the information about the column.
   *          See <I3.ArrayTableModel::addColumn> for details.
   */
  @method addFieldToIndex(field) {
    if (_base != null) _base.addFieldToIndex(arguments);
  }
  
  /**
   * Method: addFieldToSortList
   *
   * Adds a field to the sort list.  See 
   * <I3.ArrayListModel::addFieldToSortList> for more information
   * 
   * Parameters:
   *   field - an object that contains information about the field to sort on
   */
  @method addFieldToSortList(field) {
    if (_base != null) _base.addFieldToSortList(arguments);
  }
  
  /**
   * Method: enableIndex
   *
   * Turns on keyword index support for the table.  This will cause
   * <I3.TableView> to automatically display an instant-search box for
   * filtering data.
   */
  @method enableIndex() {
    _indexEnabled = true;
    if (_base != null) _base.enableIndex();
    self.getKeywordIndex = function() { return _base.getKeywordIndex(); }
  }
  
  self._initialize(uri);
}


// ---------------------------------------------------------------------------


/**
 * Class: I3.ListKeywordIndex
 *
 * Maintains an optimized index of keywords and associated identifiers.
 * An identifier can be a number (e.g. an index into an array that is
 * being maintained somewhere), a string, or even a reference to an
 * object -- whatever will be a useful result when a search is made.
 * The <I3.ListKeywordIndex::search> method will return an array of all
 * identifiers that have been associated with a given keyword.
 */
@class ListKeywordIndex {
  
  var _newKeywords;  // Keywords that have not been optimized into _searchData
  var _searchData;   // Sorted array of keywords and associated identifiers
  
  /**
   * Method: associateKeywordWithIdentifier
   *
   * Adds a keyword and its identifier to the index.  A keyword can be
   * associated with multiple identifiers by calling this method repeatedly
   * for each identifier.
   *
   * Parameters:
   *   keyword - the string to be associated with the identifier
   *   identifier - the number, string, or object to be returned as a
   *     result when a search matches the keyword
   */
  @method associateKeywordWithIdentifier(keyword, identifier) {
    if (_newKeywords == null) _newKeywords = {};
    keyword = keyword.toLowerCase();
    if (_newKeywords[keyword] == null) _newKeywords[keyword] = {};
    _newKeywords[keyword][identifier] = true;
  }
  
  /**
   * Method: prepareForSearch
   *
   * Builds the optimized index for searching.  This is automatically
   * called when the first search is made, but can be manually called
   * to pre-cache the optimized index so that the first search is faster.
   */
  @method prepareForSearch() {
    var keyword, identifiers, identifier;
    
    // Merge any existing data into the keyword map.
    if (_newKeywords == null) _newKeywords = {};
    if (_searchData != null && _searchData.length > 0) {
      for (var i = 0; i < _searchData.length; i++) {
        keyword = _searchData[i][0];
        identifiers = _searchData[i][1];
        for (var j = 0; j < identifiers.length; j++) {
          _newKeywords[keyword][identifiers[j]] = true;
        }
      }
    }

    // Create the array of keywords.
    _searchData = [];
    for (keyword in _newKeywords) {
      identifiers = [];
      for (identifier in _newKeywords[keyword]) {
        identifiers.push(identifier);
      }
      _searchData.push([keyword, identifiers]);
    }
    
    // Sort the array.
    _searchData.sort(function(a, b) {
      if (a[0] < b[0]) return -1;
      if (a[0] > b[0]) return 1;
      return 0;
    });
    
    // Reset new keywords list.
    _newKeywords = null;
  }
  
  /**
   * Method: search
   *
   * Searches the index for keywords that start with the given string.
   * The search is case-insensitive.
   * 
   * Parameters:
   *   str - the string to search for in the index
   * 
   * Returns:
   *   The array of identifiers that have been mapped to keywords
   *   that match the string.
   */
  @method search(str) {

    // Make sure all added keywords are indexed.
    if (_newKeywords != null) self.prepareForSearch();

    str = str.toLowerCase();    // Searches are case-insensitive
    var strLen = str.length;    // Referred to frequently in the routine
    var range = [];             // Start and end indices of keyword matches
    var high, low, probe;       // Used in binary search
    
    // Perform a binary search through the index for the first matching
    // keyword.  The index of the first match will become the first item
    // in the range.
    high = _searchData.length; low = -1;
    while (high - low > 1) {
      probe = Math.floor((high + low) / 2);
      if (_searchData[probe][0].substr(0, strLen) < str) low = probe;
      else high = probe;
    }
    range[0] = low + 1;
    
    // Perform a binary search through the index for the last matching
    // keyword.  The index of the last match will become the second item
    // in the range.
    high = _searchData.length; low = -1;
    while (high - low > 1) {
      probe = Math.floor((high + low) / 2);
      if (_searchData[probe][0].substr(0, strLen) > str) high = probe;
      else low = probe;
    }
    range[1] = high - 1;
    
    // Create a hash of all identifiers that have been mapped to keywords
    // in the range of matches.  This removes multiple instances of the
    // same identifier.
    var matchHash = {};
    for (var i = range[0]; i <= range[1]; i++) {
      for (var j = 0; j < _searchData[i][1].length; j++) {
        matchHash[_searchData[i][1][j]] = true;
      }
    }
    
    // Produce an array of all of the matched identifiers.
    var result = [];
    for (var identifier in matchHash) {
      result.push(identifier);
    }
    return result;
  }
}