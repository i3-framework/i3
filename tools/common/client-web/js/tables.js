/**
 * Script: common/client-web/js/tables
 *
 * Simplifies the creation of commonly used tables.
 * 
 * *Overview*
 * 
 * This file defines several classes that make it easy to create attractive,
 * sortable, searchable tables of data.  There are two pieces involved in
 * table creation: the *view*, which creates the HTML for the table and
 * handles searching and sorting, and the *model*, which provides the data
 * that the view displays.
 * 
 * *The table view*
 * 
 * The view is managed by the <I3.TableView> class.  Using the view takes
 * (at minimum) three steps:
 * 
 *   o  Tell it where to put the table.
 *   o  Tell it where to get the data that will go in the table.
 *   o  Tell it to display.
 * 
 * The first step -- providing a place for the table -- is performed when
 * you create an instance of <I3.TableView>.  You'll supply it with a
 * reference to a `div` that the view can "own" -- that is, one that it can
 * clear and re-create at will.
 * 
 * The second step is performed by calling <I3.TableView::setModel> and
 * supplying a table model object to the view.  A model object is any object
 * that provides several specific methods that the view will look for (known
 * as the "table model protocol"), such as how many rows will be in the table,
 * what the title for a given column is, and so on.  See the description
 * of <I3.TableView> for details on what methods are expected.
 * 
 * The third step is performed by simply calling <I3.TableView::display>.
 * This causes the view to query the model for the data and render it into
 * an HTML table, which is placed in the container `div`.
 * 
 * *Model classes*
 * 
 * While you can easily create your own table model classes with completely
 * custom functionality, a couple of general-use model classes are included.
 * These classes implement the table model protocol for some of the more
 * common cases so that you don't have to.
 * 
 * The first model class provided is <I3.ArrayTableModel>.  When you create
 * an instance of this, you provide an array of JavaScript objects, and the
 * `ArrayTableModel` will automatically generate columns from the fields in
 * the objects.  A single call to <I3.ArrayTableModel::enableIndex> will
 * turn on search-as-you-type support for the table.  For more control,
 * <I3.ArrayTableModel::addColumn> can be used to explicitly define the
 * columns, including titles, custom formatters, and so on.
 * 
 * The second model class is <I3.WebServiceTableModel>.  This extends
 * `ArrayTableModel` with web service support: you simply provide the path
 * to a web service that returns an array, and it takes care of the rest.
 * Like `ArrayTableModel`, you can easily enable search-as-you-type support
 * and override column behavior.
 * 
 * *Keyword indexing*
 * 
 * The <I3.KeywordIndex> class is used to associate keywords with row indices
 * in the table model.  A keyword index is automatically generated by the
 * included model classes when `enableIndex` is called, but if you're creating
 * your own table model class, you can create your own `KeywordIndex` instance
 * and use it for searches.
 * 
 * Though `I3.KeywordIndex` was created for use with `I3.TableView`, which
 * expects words to be associated with model indices, it can be used for
 * virtually anything that would benefit from an optimized index.  Keywords
 * can be associated with numbers, strings, or objects such as DOM elements;
 * whatever value you associate with the keyword is what will be returned by
 * <I3.KeywordIndex::search>.
 * 
 * *Examples*
 * 
 * Assume that you have an array of JavaScript objects named `myArray`,
 * and a `div` element named `myTableContainer` that the table will go in.
 * The following code would create a table from the array, complete with
 * clickable column headers that sort the table:
 * 
 * (start example)
 *   var view = new I3.TableView(I3.ui.get("myTableContainer"));
 *   view.setModel(new I3.ArrayTableModel(myArray));
 *   view.display();
 * (end example)
 * 
 * These three lines are all that's necessary to get a table up and running.
 * But suppose your requirements are more complex.  Let's say you have a web
 * service at the path "/assets/data/vehicles" that returns an array of
 * JavaScript objects representing vehicles.  Each vehicle object contains
 * three fields that you want to turn into columns in the table: "make",
 * "model", and "year".  In addition, each vehicle has an "owner" field,
 * which is an object representing a person.  The owner has two objects:
 * "first_name" and "last_name".  You just want to display the name in a
 * single column as "Last, First".
 * 
 * First, you'll need to define a custom formatter method that can take an
 * owner object and format it.  When the owner column is defined, this method
 * will be supplied as the "formatter" option.
 * 
 * (start example)
 *   @method formatOwner(owner) {
 *     return owner.last_name + ", " + owner.first_name;
 *   }
 * (end example)
 * 
 * You'll also need a custom comparator method that can compare two owners
 * to see how they should be sorted, since JavaScript doesn't know how to
 * sort the custom owner object by itself.  This too will be supplied when
 * the column is defined.
 * 
 * (start example)
 *   @method compareOwners(owner1, owner2) {
 *     var name1 = owner1.last_name + ", " + owner1.first_name;
 *     var name2 = owner2.last_name + ", " + owner2.first_name;
 *     if (name1 < name2) return -1;
 *     if (name1 > name2) return 1;
 *     return 0;
 *   }
 * (end example)
 * 
 * Now an <I3.WebServiceTableModel> instance can be set up with custom
 * columns.  The keyword index feature will be enabled, which the view will
 * detect and use to provide an instant-search box that filters table rows.
 * 
 * (start example)
 *   var model = new I3.WebServiceTableModel("/assets/data/vehicles");
 *   model.addColumn({ title: "Make", field: "make" });
 *   model.addColumn({ title: "Model", field: "model" });
 *   model.addColumn({ title: "Year", field: "year" });
 *   model.addColumn({ title: "Owner", field: "owner",
 *                     formatter: self.formatOwner,
 *                     comparator: self.compareOwners });
 *   model.enableIndex();
 * 
 *   var view = new I3.TableView(I3.ui.get("myTableContainer"));
 *   view.setModel(model);
 *   view.display();
 * (end example)
 * 
 * Credits:
 * 
 *   Written by
 *     Nathan Mellis (nathan@mellis.us) and
 *     Marshall Elfstrand (marshall@vengefulcow.com).
 * 
 * Copyright / License:
 * 
 *   Copyright 2009 Mission Aviation Fellowship
 * 
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 * Version:
 *   $Id: tables.js 56 2008-02-12 18:58:04Z nmellis $
 */


// ---------------------------------------------------------------------------

/**
 * Module: I3
 *
 * Module containing class definitions and data shared by all
 * intranet applications.
 */
@module I3;

// ---------------------------------------------------------------------------

/**
 * Class: I3.TableView
 *
 * Renders an HTML table from data provided by a model.  The table view can
 * be sorted by clicking on column headers, and if the table model has a
 * keyword index, an instant-search field will be provided so that the user
 * can filter the table contents on-the-fly.
 * 
 * To use the table view, a *table model* must be provided.  Table models
 * are JavaScript objects that follow a certain protocol: namely, they must
 * support a minimum of three specific methods that the view expects to find.
 * These methods are:
 * 
 *   - `getRowCount()` - returns the number of rows in the data set
 *   - `getColumnCount()` - returns the number of columns in the data set
 *   - `getValueAt(rowIndex, columnIndex)` - returns an HTML-formatted string
 *     representing the value at the given location in the data set
 * 
 * In addition, several other methods can be optionally provided by the table
 * model that will enable extra functionality if the view finds them:
 * 
 *   - `preload(onloadHandler)` - loads the data in the table model and calls
 *     the `onloadHandler` function when it is finished.  If present, the
 *     table view will display a "Loading" message and wait for the handler
 *     to be called before attempting to display the data in the model.  This
 *     can be particularly useful for models that obtain their data from a
 *     web service request.
 *   - `getColumnName(columnIndex)` - returns the name of the column at
 *     the given index.  If present, the table view will use this to generate
 *     a header row for the table with the column names in it.
 *   - `getColumnStyle(columnIndex)` - returns the CSS class name to assign
 *     to table data cells (and table header cells if applicable) for the
 *     column at the given index.
 *   - `getKeywordIndex()` - returns an <I3.KeywordIndex> instance that maps
 *     keywords to row indices in the table model.  If present, the table
 *     view will display an instant-search box for filtering the table on
 *     the fly.
 *   - `compareColumnForRows(columnIndex, rowIndex1, rowIndex2)` - compares
 *     the given column for the two rows and returns one of three values
 *     depending on how the rows compare:  `-1` if `rowIndex1` should come
 *     _before_ `rowIndex2`, `1` if `rowIndex1` should come _after_
 *     `rowIndex2`, or `0` if the two rows are identical as far as that
 *     column is concerned.  If present, the table view will use this method
 *     when sorting the data, rather than calling `getValueAt()` and comparing
 *     the values returned from it.  This is useful when, say, the table
 *     is being sorted by last name, and you want to provide custom behavior
 *     that also sorts by first name if the last names are identical.
 * 
 * A simple table model that writes out a list of coordinates might look
 * like this:
 * 
 * (start example)
 *   @class SimpleModel {
 *     @method getRowCount() {
 *       return 50;
 *     }
 *     @method getColumnCount() {
 *       return 10;
 *     }
 *     @method getValueAt(rowIndex, columnIndex) {
 *       return rowIndex.toString() + ", " + columnIndex.toString();
 *     }
 *   }
 * (end example)
 * 
 * The code used to create a table view and assign the above model to
 * it might look like this:
 * 
 * (start example)
 *   var view = new TableView(I3.ui.get("myTableContainer"));
 *   view.setModel(new SimpleModel());
 *   view.display();
 * (end example)
 * 
 * See the <I3.TableView::setTitle>, <I3.TableView::sort>, and
 * <I3.TableView::search> methods for more table view functionality.
 * 
 * Parameters:
 *   container - the HTML DOM element into which the table will be rendered
 */
@class TableView(container) {
  
  var SEARCH_DELAY = 250;   // Delay before search begins after keypress (ms)
  
  var _container;           // Table will be created in this
  var _searchTextBox;       // Text box containing search text
  var _searchStatusText;    // Span containing search status
  var _searchTimer;         // Delays search after last keypress
  var _modelDidPreload;     // Set to true when table model has preloaded
  var _modelElementMap;     // Maps model indices to table row elements
  var _modelRowIndexMap;    // Maps model indices to sorted row indices
  var _modelVisibilityMap;  // Tracks which model indices are visible
  var _modelSortMap;        // Model indices sorted by the selected column
  var _sortColumn;          // Index of the column to sort by
  var _sortIsReversed;      // Set to true when sort is descending
  var _clickedColumn;       // Index of the column header being clicked
  
  /**
   * Private Method: _initialize
   *
   * Initializes the table view.  This is called automatically when
   * an instance of the class is created.
   *
   * Parameters:
   *   container - the DOM element into which the table will be rendered
   */
  @method _initialize(container) {
    _container = container;
    _modelDidPreload = false;
    _sortColumn = -1;
    _selectedRow = -1;
    self.setSearchBoxEnabled(true);
    self.setColumnHeadersEnabled(true);
    self.setRowSelectionEnabled(false);
  }

  /**
   * Method: getModel
   * Returns the table model that will supply the data to be displayed.
   *
   * Method: setModel
   * Sets the table model that will supply the data to be displayed.
   * See the documentation for <I3.TableView> for details on what is
   * expected of a table model.
   */
  @property model;
  
  /**
   * Method: getTitle
   * Returns the title that will be displayed above the table.
   *
   * Method: setTitle
   * Sets the title that will be displayed above the table.
   * Set to `null` for no title.
   */
  @property title;

  /**
   * Method: getSearchBoxEnabled
   * Returns the setting for whether to display the instant-find box.
   *
   * Method: setSearchBoxEnabled
   * Sets whether to display the instant-find box.  The default is `true`,
   * which will automatically show the instant-find box when the table model
   * supports the `getKeywordIndex()` method.
   */
  @property searchBoxEnabled;

  /**
   * Method: getSearchBoxContainer
   * Returns the element in which the search box will be placed if enabled.
   */
  @propertyReader searchBoxContainer;
  
  /**
   * Method: setSearchBoxContainer
   * Sets the element in which the search box will be placed if enabled.
   * By default, a container element is created above the table to hold
   * the search box and its associated status text.  Setting this property
   * will prevent the creation of this element and add the search box and
   * its label to the given container instead.
   */
  @method setSearchBoxContainer(container) {
    _searchBoxContainer = I3.ui.clear(container);
  }

  /**
   * Method: getColumnHeadersEnabled
   * Returns the setting for whether to display table headers containing
   * the column names.
   *
   * Method: setColumnHeadersEnabled
   * Sets whether to display table headers containing the column names.
   * The default is `true`, which will automatically show column headers
   * when the table model supports the `getColumnName(columnIndex)` method.
   */
  @property columnHeadersEnabled;

  /**
   * Method: getRowSelectionEnabled
   * Returns the setting for whether the user can click on rows to
   * select them.
   *
   * Method: setRowSelectionEnabled
   * Returns the setting for whether the user can click on rows to
   * select them.  The default is `false`.
   */
  @property rowSelectionEnabled;
  
  /**
   * Method: getDelegate
   * Returns the delegate object for the table view.
   *
   * Method: setDelegate
   * 
   * Sets the delegate object for the table view.
   * The object may provide any or all of the following methods:
   * 
   *   tableViewDidDisplay - called when the table view has successfully
   *     finished displaying the contents of the model
   *   tableViewSelectionDidChange - called when a row has been selected
   *     in the table (see <setRowSelectionEnabled> and <getSelectedRow>)
   * 
   * Each delegate method takes a single argument, the table view
   * object that is calling the method.
   */
  @property delegate;

  /**
   * Method: getStyles
   * Returns the set of CSS styles used when rendering the table.
   *
   * Method: setStyles
   * Sets the set of CSS styles used when rendering the table.
   * Currently this is not used; the ability to override styles
   * will be added in the future.
   */
  @property styles;

  /**
   * Method: getSelectedRow
   * Returns the index of the model row that has been selected in the table.
   * When no row is selected, `-1` is returned.
   */
  @propertyReader selectedRow;
  
  /**
   * Method: setSelectedRow
   *
   * Sets the index of the model row that should be displayed as selected
   * in the table.  Set to `-1` to de-select all rows.
   * 
   * This does _not_ cause the `tableViewSelectionDidChange` delegate method
   * to be called.
   */
  @method setSelectedRow(rowIndex) {
    if (_selectedRow != -1) I3.ui.removeClassFromElement(
      _modelElementMap[_selectedRow], "i3tableRowSelected");
    _selectedRow = rowIndex;
    if (_selectedRow != -1) I3.ui.addClassToElement(
      _modelElementMap[_selectedRow], "i3tableRowSelected");
  }
  
  /**
   * Method: search
   *
   * Filters the table to only rows matching the search string.
   * This will call the model's `getKeywordIndex()` method and use
   * it to perform the search.
   * 
   * The keyword index is expected to return the rows in the table model
   * that match the search string.  The view will automatically handle the
   * mapping of the table model to the sorted table rows.
   *
   * Parameters:
   *   str - the text to search for in the table
   */
  @method search(str) {
    if (self._modelIsMissing()) return;

    // Update the text in the search box in case this was
    // done programmatically.
    if (_searchTextBox) _searchTextBox.value = str;

    // Find the rows in the model that match the search string and set
    // them to `true` in the model visibility map.
    var resultCount = -1;
    str = (str == null) ? "" : I3.util.trim(str);
    if (str.length == 0) {
      // No search; all rows are visible.
      _modelVisibilityMap = {};
      for (var i = 0; i < _model.getRowCount(); i++) {
        _modelVisibilityMap[i] = true;
      }
    }
    else {
      
      // Hide all rows in the model visibility map if it doesn't exist.
      if (_modelVisibilityMap == null) {
        _modelVisibilityMap = {};
        for (var i = 0; i < _model.getRowCount(); i++) {
          _modelVisibilityMap[i] = false;
        }
      }
      
      // Use the keyword index to get matching model rows.
      if (_model.getKeywordIndex == null) {
        I3.ui.displayError("The table cannot be searched because the " +
          "table model does not have a keyword index.");
        return;
      }
      var index = _model.getKeywordIndex();
      var searchTerms = str.split(/[^\w]/);
      var matches;
      if (searchTerms.length == 1) {
        // Just one search term.  We can use the search results as-is.
        matches = index.search(str);
      }
      else {
        // Multiple search terms.  Merge the matches into a single array
        // that only contains results shared across search terms.
        var matchMap = {};
        var newMatchMap;
        matches = index.search(searchTerms[0]);
        for (var i = 0; i < matches.length; i++) {
          matchMap[matches[i]] = true;
        }
        for (var i = 1; i < searchTerms.length; i++) {
          if (searchTerms[i].length > 0) {
            newMatchMap = {};
            matches = index.search(searchTerms[i]);
            for (var j = 0; j < matches.length; j++) {
              if (matches[j] in matchMap) newMatchMap[matches[j]] = true;
            }
            matchMap = newMatchMap;
            newMatchMap = null;
          }
        }
        matches = [];
        for (var i in matchMap) { matches.push(i); }
      }
      resultCount = matches.length;
      for (var i = 0; i < resultCount; i++) {
        _modelVisibilityMap[matches[i]] = true;
      }
    }
    
    // Update the result count display.
    if (_searchStatusText) {
      if (resultCount == -1) {
        _searchStatusText.style.display = "none";
      }
      else {
        var matchText = resultCount == 1 ? " match" : " matches";
        _searchStatusText.firstChild.data =
          "Found " + resultCount + matchText;
        _searchStatusText.style.display = "inline";
      }
    }

    // Sort the model visibility map indices by their sorted row
    // indices so that the alternating row colors are ordered properly.
    var indices = [];
    for (var index in _modelVisibilityMap) { indices.push(index); }
    indices.sort(function(a, b) {
      return _modelRowIndexMap[a] - _modelRowIndexMap[b];
    });

    // Display rows that are `true` and hide rows that are `false`
    // in the visibility map.  Once the display property has been set,
    // rows that are `false` are removed from the visibility map so
    // that further searches don't loop through them unnecessarily.
    // Rows that are `true` are reset to `false` for the next search.
    var useAlternateStyle = false;
    var index;
    for (var i = 0; i < indices.length; i++) {
      index = indices[i];
      if (_modelVisibilityMap[index] == true) {
        _modelElementMap[index].style.display = "";
        if (useAlternateStyle) {
          I3.ui.removeClassFromElement(_modelElementMap[index], "i3tableRow");
          I3.ui.addClassToElement(_modelElementMap[index], "i3tableRowAlt");
        }
        else {
          I3.ui.removeClassFromElement(_modelElementMap[index], "i3tableRowAlt");
          I3.ui.addClassToElement(_modelElementMap[index], "i3tableRow");
        }
        if (index == _selectedRow) 
          I3.ui.addClassToElement(_modelElementMap[index], "i3tableRowSelected");
        useAlternateStyle = !useAlternateStyle;
        _modelVisibilityMap[index] = false;
      }
      else {
        _modelElementMap[index].style.display = "none";
        delete _modelVisibilityMap[index];
      } // end if
    } // end for
  }

  /**
   * Method: sort
   *
   * Sorts the table by a given column.
   * 
   * If the table has already been displayed, the sort will take effect
   * immediately and the table will be re-displayed.  Otherwise the
   * table will be sorted when <I3.TableView::display> is called.
   *
   * If the table model supports the `compareColumnForRows` method,
   * it will be used to compare rows as the sort is taking place.
   * Otherwise a generic sort will be performed on the values returned
   * by the model's `getValueAt` method.
   * 
   * Parameters:
   *   columnIndex - the column to sort by
   *   shouldReverse - `true` if the sort should be done in reverse
   *     (i.e. in descending order).  Defaults to `false`.
   *   shouldRender - `true` if the table should re-display afterward.
   *     Defaults to `true`.
   */
  @method sort(columnIndex, shouldReverse, shouldRender) {
    if (shouldReverse == null) shouldReverse = false;
    if (shouldRender == null) shouldRender = true;
    var oldColumn = _sortColumn;
    _sortColumn = columnIndex;
    _sortIsReversed = shouldReverse;
    if (!_modelDidPreload) return;
    if (self._modelIsMissing()) return;
    var rowCount = _model.getRowCount();
    if (_modelSortMap == null) {
      _modelSortMap = [];
      for (var i = 0; i < rowCount; i++) {
        _modelSortMap.push(i);
      }
    }
    if (_sortColumn >= 0) {
      if (_model.compareColumnForRows) {
        // Use model's own compare function to sort the list.
        _modelSortMap.sort(function(a, b) {
          return _model.compareColumnForRows(_sortColumn, a, b);
        });
      }
      else {
        // Sort the list via a generic JavaScript sort.
        _modelSortMap.sort(function(a, b) {
          a = _model.getValueAt(a, _sortColumn).toString().toLowerCase();
          b = _model.getValueAt(b, _sortColumn).toString().toLowerCase();
          if (a < b) return -1;
          if (a > b) return 1;
          return 0;
        });
      }
    }
    // Invert the sort map.  This is used in the `search` method.
    _modelRowIndexMap = [];
    for (var i = 0; i < _modelSortMap.length; i++) {
      _modelRowIndexMap[_modelSortMap[i]] = i;
    }
    if (shouldReverse) _modelSortMap.reverse();
    if (shouldRender) self._render();
  }
  
  /**
   * Method: display
   *
   * Displays the data in the table.
   */
  @method display() {
    if (self._modelIsMissing()) return;
    if (_model.preload && !_modelDidPreload) {
      I3.ui.clear(_container);
      var loadingDiv = I3.ui.create("div");
      var loadingImg = I3.ui.create("img");
      loadingImg.src = "/$theme/client-web/img/working.gif";
      loadingDiv.className = "i3tableLoading";
      loadingDiv.appendChild(I3.ui.text("Loading... "));
      loadingDiv.appendChild(loadingImg);
      _container.appendChild(loadingDiv);
      _model.preload(self._onModelPreload);
    }
    else self._onModelPreload();
  }
  
  /**
   * Private Method: _onModelPreload
   *
   * Called when the table model has finished loading.
   *
   * Parameters:
   *   wasSuccessful - set to `false` if the data had errors loading;
   *     this will prevent the table from being displayed.  Defaults
   *     to `true`.
   */
  @method _onModelPreload(wasSuccessful) {
    if (wasSuccessful == null) wasSuccessful = true;
    if (wasSuccessful) {
      _modelDidPreload = true;
      self._render();
      if (_delegate && _delegate.tableViewDidDisplay)
        _delegate.tableViewDidDisplay(self);
    } else I3.ui.clear(_container);
  }
  
  /**
   * Private Method: _render
   *
   * Creates the table from the model.
   */
  @method _render() {
    
    // Create the sorted list if it doesn't already exist.
    if (_modelSortMap == null) self.sort(_sortColumn, _sortIsReversed, false);

    // Collect the list of column styles.
    var columnCount = _model.getColumnCount();
    var columnStyles = [];
    var i, j, className;
    if (_model.getColumnStyle) {
      for (j = 0; j < columnCount; j++) {
        className = _model.getColumnStyle(j);
        if (className == null || className == "") columnStyles.push("");
        else columnStyles.push(' class="' + className + '"');
      }
    }
    else {
      for (j = 0; j < columnCount; j++) {
        columnStyles.push("");
      }
    }

    // Create the row of column names if applicable.
    var thead = "";
    var row;
    var rowStyle = "";
    if (_columnHeadersEnabled && _model.getColumnName) {
      row = [];
      for (j = 0; j < columnCount; j++) {
        row.push(
          "<th" + columnStyles[j] + ">" + _model.getColumnName(j) + "</th>");
      }
      thead = '<thead class="i3tableHead">' + row.join("") + '</thead>';
    }

    // Save the previous search text for re-creating the search.
    var previousSearch = _searchTextBox ? _searchTextBox.value : "";
    var hasSearch = (previousSearch.length > 0);

    // Create the array of table rows from the data.
    var rows = [];
    for (i = 0; i < _modelSortMap.length; i++) {
      row = [];
      
      for (j = 0; j < columnCount; j++) {
        row.push("<td" + columnStyles[j] + ">" +
          _model.getValueAt(_modelSortMap[i], j) + "</td>");
      }
      if (_model.getRowStyle) rowStyle = _model.getRowStyle(_modelSortMap[i]);
      if (hasSearch)
        rows.push('<tr style="display:none" class="' + rowStyle + '">' + row.join("") + '</tr>');
      else rows.push('<tr class="' + rowStyle + '">' + row.join("") + '</tr>');
    }
    var tbody = "<tbody>" + rows.join("") + "</tbody>";
    
    // Reset the container, removing the "loading" text if applicable.
    I3.ui.clear(_container);
    if (_searchBoxContainer == null) {
      _searchTextBox = null;
      _searchStatusText = null;
    }
    
    // Create the title if applicable.
    if (_title) {
      var titleH = I3.ui.create("h4");
      titleH.className = "i3tableTitle";
      titleH.appendChild(I3.ui.text(_title));
      _container.appendChild(titleH);
    }
    
    // Create search box if applicable.
    if (_searchBoxEnabled && _model.getKeywordIndex && _searchTextBox == null) {
      _searchTextBox = I3.ui.create("input");
      _searchTextBox.onkeyup = self._onSearchKeyUp;
      _searchStatusText = I3.ui.create("span");
      _searchStatusText.className = "i3tableSearchStatus";
      _searchStatusText.appendChild(I3.ui.text("Sorting..."));
      var searchDiv = _searchBoxContainer;
      if (searchDiv == null) {
        searchDiv = I3.ui.create("div");
        searchDiv.className = "i3tableSearch";
        _container.appendChild(searchDiv);
      }
      searchDiv.appendChild(I3.ui.text("Find: "));
      searchDiv.appendChild(_searchTextBox);
      searchDiv.appendChild(_searchStatusText);
    }

    // Add the table data to the container.
    var tableContainer = I3.ui.create("div");
    tableContainer.className = "i3tableContainer";
    tableContainer.innerHTML = "<table>" + thead + tbody + "</table>";
    _container.appendChild(tableContainer);

    // Build the model-to-TR-element map and
    // activate row clicking if applicable.
    var trs =
      _container.getElementsByTagName("tbody")[0].getElementsByTagName("tr");
    _modelElementMap = [];
    for (i = 0; i < trs.length; i++) {
      _modelElementMap[_modelSortMap[i]] = trs[i];
      if (_rowSelectionEnabled) {
        trs[i].modelIndex = _modelSortMap[i];
        trs[i].style.cursor = "pointer";
        trs[i].onclick = self._onRowSelect;
      }
    }
    
    // Activate the column headers if applicable.
    if (thead.length > 0) {
      var ths =
        _container.getElementsByTagName("thead")[0].getElementsByTagName("th");
      for (i = 0; i < ths.length; i++) {
        if (i == _sortColumn) {
          ths[i].className += " i3tableHeadSelected";
          var arrowCode = _sortIsReversed ? "&darr;" : "&uarr;";
          ths[i].innerHTML +=
            ' <span class="i3tableHeadSelectedArrow">' + arrowCode + '</span>';
        } else {
          ths[i].innerHTML +=
            ' <span class="i3tableHeadNonSelectedArrow">&uarr;</span>';
        }
        ths[i].style.cursor = "pointer";
        ths[i].columnIndex = i;
        ths[i].onmousedown = self._onColumnMouseDown;
        ths[i].onmouseout = self._onColumnMouseOut;
        ths[i].onclick = self._onColumnSort;
      }
    }
    
    // Hide items that do not match the current search string.
    // This will also take care of the alternating-row formatting.
    _modelVisibilityMap = null;
    self.search(previousSearch);
  }

  /**
   * Private Method: _onSearchKeyUp
   *
   * Called when a key has been pressed in the search text box.
   * 
   * Parameters:
   *   e - the key-up event parameters
   */
  @method _onSearchKeyUp(e) {
    // Reset the search timeout.  We only want to call the search routine
    // when the user has finished typing.
    if (_searchTimer != null) clearTimeout(_searchTimer);
    _searchTimer = setTimeout(self._onSearchDelayComplete, SEARCH_DELAY);
    _searchStatusText.firstChild.data = "Finding...";
    I3.ui.show(_searchStatusText, "inline");
  }
  
  /**
   * Private Method: _onSearchDelayComplete
   * 
   * Called when the search delay has finished after a user keypress
   * and a search can begin.
   */
  @method _onSearchDelayComplete() {
    clearTimeout(_searchTimer);
    _searchTimer = null;
    self.search(_searchTextBox.value);
  }

  /**
   * Private Method: _onColumnMouseDown
   *
   * Called when the mouse button is pressed on a column header.
   * This changes the style of the header to make it appear indented.
   *
   * Parameters:
   *   e - the mouse down event parameters
   */
  @method _onColumnMouseDown(e) {
    e = I3.ui.getEvent(e);
    var targ = e.getTarget();
    while (targ != null && targ.nodeName.toLowerCase() != "th")
      targ = targ.parentNode;
    if (targ != null) {
      targ.className = "i3tableHeadClicked";
    }
  }
  
  /**
   * Private Method: _onColumnMouseOut
   *
   * Called when the cursor moves away from a column header.
   * This restores the style of the header to what it was before the
   * mouse-down event occurred.
   *
   * Parameters:
   *   e - the mouse out event parameters
   */
  @method _onColumnMouseOut(e) {
    e = I3.ui.getEvent(e);
    var targ = e.getTarget();
    while (targ != null && targ.nodeName.toLowerCase() != "th")
      targ = targ.parentNode;
    if (targ != null) {
      var columnIndex = targ.columnIndex;
      if (columnIndex == _sortColumn) targ.className = "i3tableHeadSelected";
      else targ.className = "";
    }
  }

  /**
   * Private Method: _onColumnSort
   *
   * Called when a column header is clicked.  The column index is
   * determined and <I3.TableView::sort> is called.
   * 
   * Parameters:
   *   e - the click event parameters
   */
  @method _onColumnSort(e) {
    var targ = I3.ui.getEvent(e).getTarget();
    if (targ.nodeName.toLowerCase() != "th")
      targ = I3.ui.getParentWithTagName("th", targ);
    if (targ != null) {
      if (_searchStatusText) {
        _searchStatusText.firstChild.data = "Sorting...";
        I3.ui.show(_searchStatusText, "inline");
      }
      var columnIndex = targ.columnIndex;
      var shouldReverse = false;
      if (columnIndex == _sortColumn) shouldReverse = !_sortIsReversed;
      // Slight delay to give "sorting..." message time to appear
      setTimeout(function() { self.sort(columnIndex, shouldReverse); }, 100);
    }
  }

  /**
   * Private Method: _onRowSelect
   *
   * Called when a row is selected.  Highlights the new row and calls
   * the delegate handler method if available.
   * 
   * Parameters:
   *   e - the click event parameters
   */
  @method _onRowSelect(e) {
    var targ = I3.ui.getParentWithTagName("tr", I3.ui.getEvent(e).getTarget());
    self.setSelectedRow(targ.modelIndex);
    if (_delegate && _delegate.tableViewSelectionDidChange)
      _delegate.tableViewSelectionDidChange(self);
  }

  /**
   * Private Method: _modelIsMissing
   *
   * Checks to see if the table model is missing or if any of the required
   * methods are missing from the table model.  If any problems are detected,
   * an error will be displayed and `true` will be returned.
   * 
   * Returns:
   *   `true` if any problems are detected with the model,
   *   `false` if the model is valid
   */
  @method _modelIsMissing() {
    if (_model == null) {
      I3.ui.displayError("The table view cannot be displayed because no " +
        "table model has been supplied via setModel().");
      return true;
    }
    var missingMethods = [];
    if (_model.getRowCount == null)
      missingMethods.push("getRowCount()");
    if (_model.getColumnCount == null)
      missingMethods.push("getColumnCount()");
    if (_model.getValueAt == null)
      missingMethods.push("getValueAt(rowIndex, columnIndex)");
    if (missingMethods.length > 0) {
      I3.ui.displayError("The table view cannot be displayed because the " +
        "table model is missing the following method(s): " +
        missingMethods.join(", "));
    }
    return false;
  }

  self._initialize(container);
}


// ---------------------------------------------------------------------------


/**
 * Class: I3.ArrayTableModel
 *
 * Implements the table model protocol for the common case of displaying
 * an array of JavaScript objects.
 * 
 * Using this class can be as simple as creating an instance and passing
 * in an array as a parameter:
 * 
 * (start example)
 *   var model = new ArrayTableModel(myArray);
 * (end example)
 * 
 * In this simple case, columns will be created from the fields in each
 * JavaScript object (using the first object as a template for what fields
 * to expect), and each value will be displayed as a string.  Dates will
 * be rendered using a locale-specific format.
 * 
 * The default behavior can be easily overridden via the
 * <I3.ArrayTable::addColumn> method.  This disables the automatic
 * column generation and lets you specify a column title, which field
 * in each JavaScript object to draw the data from, and (optionally)
 * a CSS class to use to style the table cells in that column.
 * Custom formatter and comparator functions can also be supplied.
 * 
 * Find-as-you-type is activated by calling <I3.ArrayTable::enableIndex>.
 * This will generate an <I3.KeywordIndex> and populate it with data from
 * the array.  Note that the index will use the values in the array itself,
 * not the formatted values, so formatter functions can be free to create
 * links or image tags or anything else without throwing off the index.
 * 
 * Parameters:
 *   arr - the array of data to display
 */
@class ArrayTableModel(arr) {

  var _columns;        // custom-defined columns
  var _data;           // array of table data
  var _keywordIndex;   // instance of I3.KeywordIndex

  /**
   * Private Method: _initialize
   *
   * Initializes the table model.
   * 
   * Parameters:
   *   arr - the array of data to display
   */
  @method _initialize(arr) {
    _data = arr;
  }

  /**
   * Private Method: _indexData
   * 
   * Fills the keyword index with the data from the array.
   */
  @method _indexData() {
    
    // Set up some values to compare dates against so that we know
    // which rows to associate "today" and "yesterday" with.
    var today = self._stripTime(new Date());
    var yesterday = new Date(today - 86400000);
    
    // Loop through the data row by row, column by column.
    var value, dateValue, valueParts;
    var i, j, k;
    for (i = 0; i < _data.length; i++) {
      for (j = 0; j < _columns.length; j++) {
        // Call the custom retrieve function to get the value.
        // See `addColumn` for the definition of this function.
        value = _columns[j]._retriever(_data[i]);
        if (value == null) value = "";
        // Handle dates specially.
        if (value.constructor == Date) {
          // Look for today/yesterday values.
          dateValue = self._stripTime(value);
          if (value == today)
            _keywordIndex.associateKeywordWithIdentifier("today", i);
          else if (value == yesterday)
            _keywordIndex.associateKeywordWithIdentifier("yesterday", i);
          // Index the locale-specific date string.  Since this is
          // what will generally be shown for the date in the table,
          // it makes sense to index it that way.
          value = value.toLocaleDateString();
          _keywordIndex.associateKeywordWithIdentifier(value, i);
        } else {
          // Split the string value into words and index each word.
          valueParts = value.toString().split(/[^\w]/);
          for (k = 0; k < valueParts.length; k++) {
            if (valueParts[k].length > 0)
              _keywordIndex.associateKeywordWithIdentifier(valueParts[k], i);
          } // end for
        } // end if
      } // end for
    } // end for
    
    // Now that everything is in the index, we can optimize it for searching.
    _keywordIndex.prepareForSearch();
  }
  
  /**
   * Private Method: _stripTime
   *
   * Strips the time value from a Date object.
   *
   * Parameters:
   *   dt - the Date object from which the time will be removed
   * 
   * Returns:
   *   A `Date` object with no specific time set
   */
  @method _stripTime(dt) {
    return new Date(dt.getFullYear(), dt.getMonth(), dt.getDate());
  }

  // -------------------------------------------------------------------------
  // Group: Table Model Protocol
  // -------------------------------------------------------------------------

  /**
   * Method: preload
   *
   * Loads the data needed by the model.
   * 
   * This will auto-generate the columns if necessary.
   * 
   * Parameters:
   *   onloadHandler - function to call when the data has been loaded.
   *     A boolean argument will be passed to the function to tell whether
   *     the load was successful or not (i.e. `true` if the data was loaded).
   */
  @method preload(onloadHandler) {
    if (_columns == null || _columns.length == 0) self.generateColumns();
    onloadHandler(true);
  }

  /**
   * Method: getRowCount
   *
   * Returns the number of rows to display in the table.
   */
  @method getRowCount() {
    return _data.length;
  }
  
  /**
   * Method: getColumnCount
   *
   * Returns the number of columns to display in the table, or `-1` if
   * `preload()` has not been called and no columns have been defined.
   */
  @method getColumnCount() {
    if (_columns) return _columns.length;
    else return -1;
  }
  
  /**
   * Method: getColumnName
   *
   * Returns the name to display for the given column index.
   * A `null` value will be returned if `preload()` has not been called
   * and no columns have been defined.
   *
   * Parameters:
   *   columnIndex - the zero-based index of the column
   */
  @method getColumnName(columnIndex) {
    if (_columns) return _columns[columnIndex].title;
    else return null;
  }

  /**
   * Method: getColumnStyle
   *
   * Returns the CSS class to use for the table cell that displays
   * data in the given column index.  A `null` value will be returned
   * if `preload()` not been called and no columns have been defined.
   *
   * Parameters:
   *   columnIndex - the zero-based index of the column
   */
  @method getColumnStyle(columnIndex) {
    if (_columns) return _columns[columnIndex].style;
    else return null;
  }
  
  /**
   * Method: getRowStyle
   *
   * Returns the CSS class to use for the table row.  This value can be set by setting the `style` 
   * property on a `row` in any column formatter.
   *
   * Parameters:
   *   rowIndex - the zero-based index of the row
   */
  @method getRowStyle(rowIndex) {
    if (_rowFormatter) return _rowFormatter(_data[rowIndex]);
    else return "";
  }
  
  /**
   * Method: getValueAt
   *
   * Returns the HTML to display in the cell for the given row/column pair.
   * 
   * See <I3.ArrayTableModel::addColumn> for details on how to override
   * the output for a cell in array-based table models.
   *
   * Parameters:
   *   rowIndex - the index of the row being rendered by the view
   *   columnIndex - the index of the column being rendered by the view
   */
  @method getValueAt(rowIndex, columnIndex) {
    var value = _columns[columnIndex]._retriever(_data[rowIndex]);
    if (_columns[columnIndex].formatter)
      return _columns[columnIndex].formatter(
        value, _columns[columnIndex].field, _data[rowIndex]);
    else if (value == null)
      return "";
    else if (value.constructor == Date)
      return value.toLocaleDateString();
    else
      return value.toString().replace(
        '&', '&amp;').replace('<', '&lt;').replace('>', '&gt;');
  }
  
  /**
   * Method: compareColumnForRows
   *
   * Compares two rows for sorting.
   * 
   * See <I3.ArrayTableModel::addColumn> for details on how to
   * override the sort behavior in web service table models.
   *
   * Parameters:
   *   columnIndex - the index of the column to sort by
   *   rowIndex1 - the index of the first row to compare
   *   rowIndex2 - the index of the second row to compare
   * 
   * Returns:
   *   - `-1` if the first row should come before the second one
   *   - `0` if the two rows are identical as far as sorting is concerned
   *   - `1` if the first row should come after the second one
   */
  @method compareColumnForRows(columnIndex, rowIndex1, rowIndex2) {
    var value1 = _columns[columnIndex]._retriever(_data[rowIndex1]);
    var value2 = _columns[columnIndex]._retriever(_data[rowIndex2]);
    if (value1 == null) value1 = "";
    if (value2 == null) value2 = "";
    if (_columns[columnIndex].comparator)
      return _columns[columnIndex].comparator(value1, value2,
        _columns[columnIndex].field, _data[rowIndex1], _data[rowIndex2]);
    else {
      if ((value1.constructor == Number && value2.constructor == Number) ||
          (value1.constructor == Date && value2.constructor == Date)) {
        return value1 - value2;
      }
      else {
        value1 = value1.toString().toLowerCase();
        value2 = value2.toString().toLowerCase();
        if (value1 < value2) return -1;
        if (value1 > value2) return 1;
        return 0;
      }
    }
  }
  
  // -------------------------------------------------------------------------
  // Group: Customization
  // -------------------------------------------------------------------------
  
  /**
   * Method: getRowFormatter
   * Returns the function that will be called to determine additional row styles.
   *
   * Method: setRowFormatter
   * Sets the function that will be called to determine additional row styles.
   * Since sometimes it is desirable to set the color of a row based on the contents of its data, 
   * a function can be specified that will return a string that will be appended to the row's 
   * `class` attribute.  These styles will be in addition to those already added by <I3.TableView> 
   * such as `i3tableRow` and `i3tableRowAlt`.
   * 
   * The function that is passed in here should take a single `row` argument that will contain the 
   * data of the row currently being rendered.  It should return a string containing a 
   * space-separated list of CSS styles that should be applied to the table's row element.
   * 
   * Example:
   * (start example)
   * var model = new I3.ArrayTableModel(data)
   * model.setRowFormatter(
   *   function(row) {
   *     if (row.is_complete) return "completedItem";
   *   })
   * (end example)
   */
  @property rowFormatter;

  /**
   * Method: addColumn
   *
   * Adds a column to the model.  This turns off auto-generation of columns.
   * The column info structure has the following properties:
   * 
   *   title - the name to display for the column
   *   field - the name of the field in the row data; a chain of fields
   *     can be specified using dot notation (e.g. "customer.name")
   *   retriever - optional; a function to use to retrieve the data from
   *     the object
   *   formatter - optional; a function to use to format the data when
   *     it needs to be displayed
   *   comparator - optional; a function used to compare two rows
   *     when the data is being sorted
   *   style - optional; a CSS class name to assign to the table cell
   *     when it is rendered
   * 
   * Retriever functions:
   * 
   * The `retriever` function, if specified, needs to support a single `row`
   * argument, which will be the JavaScript object being processed.  The
   * retriever function is expected to return an object that can either be
   * displayed as-is (e.g. a string) or that can be further processed by
   * a formatter function.
   * 
   * Retriever functions are useful for creating virtual columns, such
   * as a full name composed of multiple name fields.  If indexing is enabled,
   * the indexed keywords will be extracted from the value returned by the
   * retriever function.
   * 
   * Formatter functions:
   * 
   * The `formatter` function, if specified, needs to support the following
   * arguments:
   * 
   *   value - the value being formatted
   *   field - the name of the field providing the value
   *   row - the data for the entire row
   * 
   * The function should return a string.  The string may include HTML
   * if appropriate.
   * 
   * The formatter can be as simple or as complex as you like.  A generic
   * formatter might take a date `value` and return a more friendly string,
   * ignoring the `field` and `row` arguments.  A more specific formatter
   * might pull multiple fields from the `row` data and combine them into
   * a single value (such as a permalink combined with a name to form a
   * hyperlink).
   * 
   * Comparator functions:
   * 
   * The `comparator` function is called when a table view needs to sort
   * the items in the model.  By default, a generic JavaScript sort will
   * be used; the `comparator` function overrides this.  If specified, it
   * needs to support the following arguments:
   * 
   *   value1 - the first value being compared
   *   value2 - the second value being compared
   *   field - the name of the field that the list is being sorted on
   *   row1 - the data for the first row being compared
   *   row2 - the data for the second row being compared
   * 
   * The function should compare the two items and return one of the
   * following integer values:
   * 
   *   - `-1` if the first item comes before the second one
   *   - `0` if the two items are equal
   *   - `1` if the first item comes after the second one
   * 
   * As with the `formatter` function, the comparator can be a generic one
   * that simply compares the two values, or it can be more specific and
   * compare multiple fields from the rows (e.g. a last name and a first
   * name).
   * 
   * Parameters:
   *   info - the information about the column
   */
  @method addColumn(info) {
    if (_columns == null) _columns = [];
    if (info.retriever) info._retriever = info.retriever;
    else info._retriever = eval(
      '({ retriever: function(row) { ' +
        'try { return row.'+info.field+'; } catch (ex) { return null; } ' +
      '} })').retriever;
    _columns.push(info);
  }
  
  /**
   * Method: enableIndex
   *
   * Turns on keyword index support for the table.  This will cause
   * <I3.TableView> to automatically display an instant-search box for
   * filtering data.
   * 
   * If columns have not been defined manually, they will be auto-generated
   * at this point.
   */
  @method enableIndex() {
    if (_columns == null) self.generateColumns();
    if (_keywordIndex == null) {
      _keywordIndex = new I3.KeywordIndex();
      if (_data.length > 0) self._indexData();
      self.getKeywordIndex = function() { return _keywordIndex; }
    }
  }
  
  /**
   * Method: generateColumns
   *
   * Auto-generates the columns from the properties of the first
   * object in the array.  This is automatically called by `preload()`
   * unless columns are explicitly defined using `addColumn()`.
   */
  @method generateColumns() {
    var fieldNames = [];
    for (var key in _data[0]) { fieldNames.push(key); }
    fieldNames.sort();
    for (var i = 0; i < fieldNames.length; i++) {
      self.addColumn({ title:fieldNames[i], field:fieldNames[i] });
    }
  }
  
  self._initialize(arr);
}


// ---------------------------------------------------------------------------


/**
 * Class: I3.WebServiceTableModel
 *
 * Implements the table model protocol for the common instance of retrieving
 * an array from a web service.
 * 
 * This provides the same functionality as <I3.ArrayTableModel>, except
 * you provide it with the path of a web service instead of an array.
 * The table view will automatically display a "Loading" message as the
 * data loads, and the data will be displayed when the response has been
 * received.
 * 
 * The response is expected to be an array.  If the response is an object
 * and the array to be displayed is a member of the object, the path to the
 * array can be specified using <I3.WebServiceTableModel::setObjectKeyPath>.
 * 
 * As with <I3.ArrayTableModel>, columns can be defined using `addColumn()`,
 * and find-as-you-type can be enabled via `enableIndex()`.
 * 
 * Parameters:
 *   uri - the path of the web service to load
 */
@class WebServiceTableModel(uri) {

  var _base;             // underlying I3.ArrayTableModel instance
  var _webServiceURI;    // path to web service
  var _onloadHandler;    // function to call when data has loaded
  var _columns;          // custom-defined columns
  var _indexEnabled;     // true if enableIndex() has been called

  /**
   * Private Method: _initialize
   *
   * Initializes the table model.
   * 
   * Parameters:
   *   uri - the path of the web service to load
   */
  @method _initialize(uri) {
    _webServiceURI = uri;
  }

  /**
   * Private Method: _onWebServiceResponse
   *
   * Called when the web service has responded.  Loads the data into
   * the internal array table model, auto-generates columns if necessary,
   * and calls the handler function that was given when `preload()` was
   * called.
   *
   * Parameters:
   *   response - an `I3.ObjectResponse` containing the array of data
   */
  @method _onWebServiceResponse(response) {
    var status = false;
    if (response.isOK()) {
      var data = response.getObject();
      // Follow the object key path if necesssary.
      if (_objectKeyPath && _objectKeyPath.length > 0) {
        var navigatePath =
          eval('function(obj) { return obj.' + _objectKeyPath + '; }');
        data = navigatePath(data);
      }
      // Create the array table model and define custom
      // columns if necessary.
      _base = new I3.ArrayTableModel(data);
      if (_columns == null) _base.generateColumns();
      else {
        for (var i = 0; i < _columns.length; i++) {
          _base.addColumn(_columns[i]);
        }
      }
      if (_indexEnabled) _base.enableIndex();
      status = true;
    }
    // Call the handler method that was specified in `preload()`.
    if (_onloadHandler) _onloadHandler(status);
  }

  // -------------------------------------------------------------------------
  // Group: Table Model Protocol
  // -------------------------------------------------------------------------

  /**
   * Method: preload
   *
   * Loads the data needed by the model.
   * 
   * This will start the web service request.  The table view will be
   * notified when it is finished via the `onloadHandler` function.
   * 
   * Parameters:
   *   onloadHandler - function to call when the data has been loaded.
   *     A boolean argument will be passed to the function to tell whether
   *     the load was successful or not (e.g. `true` if the data was loaded).
   */
  @method preload(onloadHandler) {
    _onloadHandler = onloadHandler;
    I3.client.getObject(_webServiceURI, self._onWebServiceResponse);
  }

  /**
   * Method: getRowCount
   *
   * Returns the number of rows to display in the table, or `-1` if the
   * data has not yet been loaded.
   */
  @method getRowCount() {
    if (_base) return _base.getRowCount();
    else return -1;
  }
  
  /**
   * Method: getColumnCount
   *
   * Returns the number of columns to display in the table, or `-1` if
   * the data has not yet been loaded and no columns have been defined.
   */
  @method getColumnCount() {
    if (_base) return _base.getColumnCount();
    else return -1;
  }
  
  /**
   * Method: getColumnName
   *
   * Returns the name to display for the given column index.
   * A `null` value will be returned if the data has not yet been loaded
   * and no columns have been defined.
   *
   * Parameters:
   *   columnIndex - the zero-based index of the column
   */
  @method getColumnName(columnIndex) {
    if (_base) return _base.getColumnName(columnIndex);
    else if (_columns) return _columns[columnIndex].title;
    else return null;
  }

  /**
   * Method: getColumnStyle
   *
   * Returns the CSS class to use for the table cell that displays
   * data in the given column index.  A `null` value will be returned
   * if the data has not yet been loaded and no columns have been defined.
   *
   * Parameters:
   *   columnIndex - the zero-based index of the column
   */
  @method getColumnStyle(columnIndex) {
    if (_base) return _base.getColumnStyle(columnIndex);
    else if (_columns) return _columns[columnIndex].style;
    else return null;
  }
  
  /**
   * Method: getRowStyle
   *
   * Returns the CSS class to use for the table row.  If a function was specified in 
   * <setRowFormatter> it will be called and the string will be returned
   *
   * Parameters:
   *   rowIndex - the zero-based index of the row
   */
  @method getRowStyle(rowIndex) {
    if (_base) return _base.getRowStyle(rowIndex);
    else return "";
  }
  
  /**
   * Method: getValueAt
   *
   * Returns the HTML to display in the cell for the given row/column pair.
   * 
   * See <I3.ArrayTableModel::addColumn> for details on how to override
   * the output for a cell.
   *
   * Parameters:
   *   rowIndex - the index of the row being rendered by the view
   *   columnIndex - the index of the column being rendered by the view
   */
  @method getValueAt(rowIndex, columnIndex) {
    if (_base) return _base.getValueAt(rowIndex, columnIndex);
    else return null;
  }
  
  /**
   * Method: compareColumnForRows
   *
   * Compares two rows for sorting.
   * 
   * See <I3.ArrayTableModel::addColumn> for details on how to
   * override the sort behavior.
   *
   * Parameters:
   *   columnIndex - the index of the column to sort by
   *   rowIndex1 - the index of the first row to compare
   *   rowIndex2 - the index of the second row to compare
   * 
   * Returns:
   *   - `-1` if the first row should come before the second one
   *   - `0` if the two rows are identical as far as sorting is concerned
   *   - `1` if the first row should come after the second one
   */
  @method compareColumnForRows(columnIndex, rowIndex1, rowIndex2) {
    if (_base)
      return _base.compareColumnForRows(columnIndex, rowIndex1, rowIndex2);
    else return null;
  }
  

  // -------------------------------------------------------------------------
  // Group: Customization
  // -------------------------------------------------------------------------
  
  /**
   * Method: getObjectKeyPath
   * Returns the path to the array in the response data.
   *
   * Method: setObjectKeyPath
   * Sets the path to the array in the response data.
   * By default, it is assumed that the root object returned by the
   * web service is the array.  If the array to be displayed is a
   * property of the root object (even one that is multiple levels deep),
   * the name of the property can be set here.  A chain of properties
   * can be specified using dot notation (e.g. "resources.computers").
   */
  @property objectKeyPath;
  
  /**
   * Method: getRowFormatter
   * Returns the function that will be called to determine additional row styles.
   */
  @method getRowFormatter() {
    if (_base) return _base.getRowFormatter();
    else return null;
  }
  
  /*
   * Method: setRowFormatter
   * Sets the function that will be called to determine additional row styles.
   * Since sometimes it is desirable to set the color of a row based on the contents of its data, 
   * a function can be specified that will return a string that will be appended to the row's 
   * `class` attribute.  These styles will be in addition to those already added by <I3.TableView> 
   * such as `i3tableRow` and `i3tableRowAlt`.
   * 
   * The function that is passed in here should take a single `row` argument that will contain the 
   * data of the row currently being rendered.  It should return a string containing a 
   * space-separated list of CSS styles that should be applied to the table's row element.
   * 
   * Example:
   * (start example)
   * var model = new I3.WebServiceTableModel("/path/to/web/service")
   * model.setRowFormatter(
   *   function(row) {
   *     if (row.is_complete) return "completedItem";
   *   })
   * (end example)
   * 
   * Parameters:
   *   func - the function to call to determine the row formatting
   */
  @method setRowFormatter(func) {
    if (_base) _base.setRowFormatter(func);
  }

  /**
   * Method: addColumn
   *
   * Adds a column to the model.  This turns off auto-generation of columns.
   * 
   * Parameters:
   *   info - the information about the column.
   *          See <I3.ArrayTableModel::addColumn> for details.
   */
  @method addColumn(info) {
    if (_columns == null) _columns = [];
    _columns.push(info);
  }
  
  /**
   * Method: enableIndex
   *
   * Turns on keyword index support for the table.  This will cause
   * <I3.TableView> to automatically display an instant-search box for
   * filtering data.
   */
  @method enableIndex() {
    _indexEnabled = true;
    if (_base != null) _base.enableIndex();
    self.getKeywordIndex = function() { return _base.getKeywordIndex(); }
  }
  
  self._initialize(uri);
}


// ---------------------------------------------------------------------------


/**
 * Class: I3.KeywordIndex
 *
 * Maintains an optimized index of keywords and associated identifiers.
 * An identifier can be a number (e.g. an index into an array that is
 * being maintained somewhere), a string, or even a reference to an
 * object -- whatever will be a useful result when a search is made.
 * The <I3.KeywordIndex::search> method will return an array of all
 * identifiers that have been associated with a given keyword.
 */
@class KeywordIndex {
  
  var _newKeywords;  // Keywords that have not been optimized into _searchData
  var _searchData;   // Sorted array of keywords and associated identifiers
  
  /**
   * Method: associateKeywordWithIdentifier
   *
   * Adds a keyword and its identifier to the index.  A keyword can be
   * associated with multiple identifiers by calling this method repeatedly
   * for each identifier.
   *
   * Parameters:
   *   keyword - the string to be associated with the identifier
   *   identifier - the number, string, or object to be returned as a
   *     result when a search matches the keyword
   */
  @method associateKeywordWithIdentifier(keyword, identifier) {
    if (_newKeywords == null) _newKeywords = {};
    keyword = keyword.toLowerCase();
    if (_newKeywords[keyword] == null) _newKeywords[keyword] = {};
    _newKeywords[keyword][identifier] = true;
  }
  
  /**
   * Method: prepareForSearch
   *
   * Builds the optimized index for searching.  This is automatically
   * called when the first search is made, but can be manually called
   * to pre-cache the optimized index so that the first search is faster.
   */
  @method prepareForSearch() {
    var keyword, identifiers, identifier;
    
    // Merge any existing data into the keyword map.
    if (_newKeywords == null) _newKeywords = {};
    if (_searchData != null && _searchData.length > 0) {
      for (var i = 0; i < _searchData.length; i++) {
        keyword = _searchData[i][0];
        identifiers = _searchData[i][1];
        for (var j = 0; j < identifiers.length; j++) {
          _newKeywords[keyword][identifiers[j]] = true;
        }
      }
    }

    // Create the array of keywords.
    _searchData = [];
    for (keyword in _newKeywords) {
      identifiers = [];
      for (identifier in _newKeywords[keyword]) {
        identifiers.push(identifier);
      }
      _searchData.push([keyword, identifiers]);
    }
    
    // Sort the array.
    _searchData.sort(function(a, b) {
      if (a[0] < b[0]) return -1;
      if (a[0] > b[0]) return 1;
      return 0;
    });
    
    // Reset new keywords list.
    _newKeywords = null;
  }
  
  /**
   * Method: search
   *
   * Searches the index for keywords that start with the given string.
   * The search is case-insensitive.
   * 
   * Parameters:
   *   str - the string to search for in the index
   * 
   * Returns:
   *   The array of identifiers that have been mapped to keywords
   *   that match the string.
   */
  @method search(str) {

    // Make sure all added keywords are indexed.
    if (_newKeywords != null) self.prepareForSearch();

    str = str.toLowerCase();    // Searches are case-insensitive
    var strLen = str.length;    // Referred to frequently in the routine
    var range = [];             // Start and end indices of keyword matches
    var high, low, probe;       // Used in binary search
    
    // Perform a binary search through the index for the first matching
    // keyword.  The index of the first match will become the first item
    // in the range.
    high = _searchData.length; low = -1;
    while (high - low > 1) {
      probe = Math.floor((high + low) / 2);
      if (_searchData[probe][0].substr(0, strLen) < str) low = probe;
      else high = probe;
    }
    range[0] = low + 1;
    
    // Perform a binary search through the index for the last matching
    // keyword.  The index of the last match will become the second item
    // in the range.
    high = _searchData.length; low = -1;
    while (high - low > 1) {
      probe = Math.floor((high + low) / 2);
      if (_searchData[probe][0].substr(0, strLen) > str) high = probe;
      else low = probe;
    }
    range[1] = high - 1;
    
    // Create a hash of all identifiers that have been mapped to keywords
    // in the range of matches.  This removes multiple instances of the
    // same identifier.
    var matchHash = {};
    for (var i = range[0]; i <= range[1]; i++) {
      for (var j = 0; j < _searchData[i][1].length; j++) {
        matchHash[_searchData[i][1][j]] = true;
      }
    }
    
    // Produce an array of all of the matched identifiers.
    var result = [];
    for (var identifier in matchHash) {
      result.push(identifier);
    }
    return result;
  }

}